<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Integration Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 4px solid #ccc;
        }
        
        .success {
            background: #d4edda;
            border-left-color: #28a745;
            color: #155724;
        }
        
        .error {
            background: #f8d7da;
            border-left-color: #dc3545;
            color: #721c24;
        }
        
        .info {
            background: #d1ecf1;
            border-left-color: #17a2b8;
            color: #0c5460;
        }
        
        .warning {
            background: #fff3cd;
            border-left-color: #ffc107;
            color: #856404;
        }
        
        .test-section {
            margin-bottom: 30px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
        }
        
        .mode-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 1000;
        }
        
        .mode-telegram {
            background: #0088cc;
            color: white;
        }
        
        .mode-fallback {
            background: #ff9800;
            color: white;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .main-button-state {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        
        .feature-item {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
        }
        
        .feature-available {
            background: #d4edda;
            border-color: #28a745;
        }
        
        .feature-unavailable {
            background: #f8d7da;
            border-color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üß™ Telegram Integration Test</h1>
        <p>This test verifies Telegram Web App integration and fallback modes work correctly.</p>
        
        <div id="mode-indicator" class="mode-indicator">
            Detecting mode...
        </div>
        
        <div id="test-results"></div>
        
        <div class="test-section">
            <h3>Environment Information</h3>
            <div id="environment-info"></div>
        </div>
        
        <div class="test-section">
            <h3>Telegram Features Test</h3>
            <div id="telegram-features"></div>
        </div>
        
        <div class="test-section">
            <h3>Main Button Test</h3>
            <div id="main-button-state" class="main-button-state">
                Loading main button state...
            </div>
            <button onclick="testMainButton()">Test Main Button</button>
            <button onclick="testMainButtonLoading()">Test Loading State</button>
            <button onclick="hideMainButton()">Hide Main Button</button>
        </div>
        
        <div class="test-section">
            <h3>User Data Test</h3>
            <div id="user-data-info"></div>
        </div>
        
        <div class="test-section">
            <h3>Integration Test Controls</h3>
            <button onclick="runFullIntegrationTest()">Run Full Integration Test</button>
            <button onclick="testErrorHandling()">Test Error Handling</button>
            <button onclick="testFallbackMode()">Force Fallback Mode</button>
            <button onclick="clearTestResults()">Clear Results</button>
        </div>
        
        <div class="test-section">
            <h3>Development Tools</h3>
            <button onclick="toggleMode()">Toggle Mode</button>
            <button onclick="simulateError()">Simulate Error</button>
            <button onclick="testHapticFeedback()">Test Haptic Feedback</button>
            <button onclick="showModeInfo()">Show Mode Info</button>
        </div>
    </div>

    <!-- Load test dependencies -->
    <script src="src/core/interfaces.js"></script>
    <script src="src/core/Logger.js"></script>
    <script src="src/core/ErrorHandler.js"></script>
    <script src="src/adapters/TelegramAdapter.js"></script>

    <script>
        let adapter = null;
        let testResults = [];
        
        function log(message, type = 'info') {
            const results = document.getElementById('test-results');
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.innerHTML = `<strong>${new Date().toLocaleTimeString()}</strong>: ${message}`;
            results.appendChild(div);
            
            testResults.push({ message, type, timestamp: Date.now() });
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function clearTestResults() {
            document.getElementById('test-results').innerHTML = '';
            testResults = [];
        }
        
        function updateModeIndicator(mode, reason = '') {
            const indicator = document.getElementById('mode-indicator');
            indicator.className = `mode-indicator mode-${mode}`;
            indicator.textContent = `${mode.toUpperCase()} MODE${reason ? ` (${reason})` : ''}`;
        }
        
        async function initializeTest() {
            try {
                log('üß™ Starting Telegram Integration Test...', 'info');
                
                // Initialize TelegramAdapter
                adapter = window.TelegramAdapter;
                if (!adapter) {
                    throw new Error('TelegramAdapter not found');
                }
                
                // Initialize adapter
                await adapter.initialize();
                
                // Update mode indicator
                const modeInfo = adapter.getModeInfo();
                updateModeIndicator(modeInfo.mode, modeInfo.fallbackReason);
                
                // Display environment info
                displayEnvironmentInfo(modeInfo);
                
                // Display telegram features
                displayTelegramFeatures(modeInfo);
                
                // Display user data
                displayUserData();
                
                // Update main button state
                updateMainButtonState();
                
                log('‚úÖ Test initialization completed', 'success');
                
            } catch (error) {
                log(`‚ùå Test initialization failed: ${error.message}`, 'error');
                updateModeIndicator('error', error.message);
            }
        }
        
        function displayEnvironmentInfo(modeInfo) {
            const info = document.getElementById('environment-info');
            info.innerHTML = `
                <div><strong>Mode:</strong> ${modeInfo.mode}</div>
                <div><strong>Initialized:</strong> ${modeInfo.isInitialized}</div>
                <div><strong>URL:</strong> ${window.location.href}</div>
                <div><strong>User Agent:</strong> ${navigator.userAgent.substring(0, 100)}...</div>
                <div><strong>Telegram API Available:</strong> ${!!(window.Telegram && window.Telegram.WebApp)}</div>
                ${modeInfo.fallbackReason ? `<div><strong>Fallback Reason:</strong> ${modeInfo.fallbackReason}</div>` : ''}
            `;
        }
        
        function displayTelegramFeatures(modeInfo) {
            const features = document.getElementById('telegram-features');
            
            if (modeInfo.features) {
                const featureElements = Object.entries(modeInfo.features).map(([name, available]) => 
                    `<div class="feature-item feature-${available ? 'available' : 'unavailable'}">
                        <strong>${name}</strong><br>
                        ${available ? '‚úÖ Available' : '‚ùå Not Available'}
                    </div>`
                ).join('');
                
                features.innerHTML = `<div class="feature-grid">${featureElements}</div>`;
            } else {
                features.innerHTML = '<div class="test-result warning">No Telegram features available in fallback mode</div>';
            }
        }
        
        function displayUserData() {
            const userInfo = document.getElementById('user-data-info');
            
            try {
                const userData = adapter.getUserData();
                userInfo.innerHTML = `
                    <div><strong>User ID:</strong> ${userData.id}</div>
                    <div><strong>Username:</strong> ${userData.username || 'N/A'}</div>
                    <div><strong>First Name:</strong> ${userData.firstName}</div>
                    <div><strong>Last Name:</strong> ${userData.lastName || 'N/A'}</div>
                    <div><strong>Language:</strong> ${userData.languageCode || 'N/A'}</div>
                    <div><strong>Premium:</strong> ${userData.isPremium ? 'Yes' : 'No'}</div>
                `;
            } catch (error) {
                userInfo.innerHTML = `<div class="test-result error">Failed to get user data: ${error.message}</div>`;
            }
        }
        
        function updateMainButtonState() {
            const stateElement = document.getElementById('main-button-state');
            const state = adapter.getMainButtonState();
            
            stateElement.innerHTML = `
                <strong>Main Button State:</strong><br>
                Available: ${state.available}<br>
                Visible: ${state.visible}<br>
                Enabled: ${state.enabled}<br>
                Loading: ${state.loading}<br>
                Text: ${state.text || 'N/A'}
            `;
        }
        
        async function testMainButton() {
            try {
                log('üîò Testing main button...', 'info');
                
                const result = await adapter.showMainButton('üß™ Test Button', () => {
                    log('‚úÖ Main button clicked!', 'success');
                    adapter.hideMainButton();
                });
                
                if (result) {
                    log('‚úÖ Main button shown successfully', 'success');
                } else {
                    log('‚ö†Ô∏è Main button show returned false', 'warning');
                }
                
                updateMainButtonState();
                
            } catch (error) {
                log(`‚ùå Main button test failed: ${error.message}`, 'error');
            }
        }
        
        async function testMainButtonLoading() {
            try {
                log('‚è≥ Testing main button loading state...', 'info');
                
                await adapter.setMainButtonLoading(true);
                updateMainButtonState();
                
                setTimeout(async () => {
                    await adapter.setMainButtonLoading(false);
                    updateMainButtonState();
                    log('‚úÖ Loading state test completed', 'success');
                }, 2000);
                
            } catch (error) {
                log(`‚ùå Loading state test failed: ${error.message}`, 'error');
            }
        }
        
        async function hideMainButton() {
            try {
                log('üôà Hiding main button...', 'info');
                await adapter.hideMainButton();
                updateMainButtonState();
                log('‚úÖ Main button hidden', 'success');
            } catch (error) {
                log(`‚ùå Failed to hide main button: ${error.message}`, 'error');
            }
        }
        
        async function runFullIntegrationTest() {
            clearTestResults();
            log('üöÄ Starting full integration test...', 'info');
            
            try {
                // Test 1: Basic functionality
                log('üìã Testing basic functionality...', 'info');
                const modeInfo = adapter.getModeInfo();
                log(`Mode: ${modeInfo.mode}`, 'info');
                
                // Test 2: User data
                log('üìã Testing user data...', 'info');
                const userData = adapter.getUserData();
                log(`User: ${userData.username} (${userData.id})`, 'info');
                
                // Test 3: Main button
                log('üìã Testing main button...', 'info');
                await testMainButton();
                
                // Test 4: Haptic feedback
                log('üìã Testing haptic feedback...', 'info');
                adapter.sendHapticFeedback('light');
                
                // Test 5: Method availability
                log('üìã Testing method availability...', 'info');
                const methods = ['MainButton.show', 'HapticFeedback.impactOccurred', 'close'];
                methods.forEach(method => {
                    const available = adapter.isMethodAvailable(method);
                    log(`${method}: ${available ? '‚úÖ' : '‚ùå'}`, available ? 'success' : 'warning');
                });
                
                log('üéâ Full integration test completed!', 'success');
                
            } catch (error) {
                log(`‚ùå Integration test failed: ${error.message}`, 'error');
            }
        }
        
        async function testErrorHandling() {
            log('üß™ Testing error handling...', 'info');
            
            try {
                // Test invalid main button parameters
                await adapter.showMainButton('', null);
            } catch (error) {
                log(`‚úÖ Error handling working: ${error.message}`, 'success');
            }
            
            // Test method availability on non-existent methods
            const invalid = adapter.isMethodAvailable('NonExistent.method');
            log(`Invalid method check: ${!invalid ? '‚úÖ' : '‚ùå'}`, !invalid ? 'success' : 'error');
        }
        
        async function testFallbackMode() {
            log('üîÑ Testing fallback mode...', 'info');
            
            localStorage.setItem('fanzone_fallback_mode', 'true');
            log('‚úÖ Fallback mode enabled, refresh page to test', 'success');
        }
        
        async function toggleMode() {
            if (adapter && adapter.toggleFallbackMode) {
                await adapter.toggleFallbackMode();
            } else {
                log('‚ùå Toggle mode not available', 'error');
            }
        }
        
        function simulateError() {
            try {
                throw new Error('Simulated test error');
            } catch (error) {
                if (window.ErrorHandler) {
                    const errorInfo = window.ErrorHandler.handleInitError(error, 'test_simulation');
                    log(`‚úÖ Error simulation handled: ${errorInfo.category}`, 'success');
                } else {
                    log('‚ö†Ô∏è ErrorHandler not available', 'warning');
                }
            }
        }
        
        function testHapticFeedback() {
            const types = ['light', 'medium', 'heavy', 'success', 'error', 'warning'];
            
            types.forEach((type, index) => {
                setTimeout(() => {
                    adapter.sendHapticFeedback(type);
                    log(`üì≥ Haptic feedback: ${type}`, 'info');
                }, index * 500);
            });
        }
        
        function showModeInfo() {
            const modeInfo = adapter.getModeInfo();
            const infoText = JSON.stringify(modeInfo, null, 2);
            
            log('üìä Mode Information:', 'info');
            log(`<pre>${infoText}</pre>`, 'info');
        }
        
        // Initialize test when page loads
        document.addEventListener('DOMContentLoaded', initializeTest);
        
        // Update main button state periodically
        setInterval(updateMainButtonState, 2000);
    </script>
</body>
</html>