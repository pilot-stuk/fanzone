<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentication Enhancement Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .test-section {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .test-button {
            background: #3390ec;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        
        .test-button:hover {
            background: #2980d9;
        }
        
        .test-result {
            background: #f8f9fa;
            border-left: 4px solid #28a745;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .test-error {
            border-left-color: #dc3545;
            background: #f8d7da;
        }
        
        .log-container {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            margin: 10px 0;
        }
        
        .log-info { color: #63b3ed; }
        .log-warn { color: #f6ad55; }
        .log-error { color: #fc8181; }
        .log-debug { color: #9ae6b4; }
    </style>
</head>
<body>
    <h1>üîç Authentication Enhancement Test</h1>
    <p>This page tests the enhanced Telegram authentication flow with improved database integration, retry mechanisms, and debug logging.</p>
    
    <div class="test-section">
        <h3>Test Configuration</h3>
        <label>
            <input type="checkbox" id="enableDebugLogging" checked> Enable Debug Logging
        </label>
        <br>
        <label>
            <input type="checkbox" id="simulateDbFailure"> Simulate Database Failure
        </label>
        <br>
        <label>
            <input type="checkbox" id="simulateRlsError"> Simulate RLS Permission Error
        </label>
    </div>
    
    <div class="test-section">
        <h3>Authentication Tests</h3>
        <button class="test-button" onclick="testNewUserCreation()">Test New User Creation</button>
        <button class="test-button" onclick="testExistingUserAuth()">Test Existing User Auth</button>
        <button class="test-button" onclick="testRetryMechanism()">Test Retry Mechanism</button>
        <button class="test-button" onclick="testGiftPermissions()">Test Gift Permissions</button>
        <button class="test-button" onclick="clearLogs()">Clear Logs</button>
    </div>
    
    <div class="test-section">
        <h3>Test Results</h3>
        <div id="testResults"></div>
    </div>
    
    <div class="test-section">
        <h3>Debug Logs</h3>
        <div id="logContainer" class="log-container"></div>
    </div>

    <script>
        // Mock configuration
        window.CONFIG = {
            POINTS: { INITIAL_POINTS: 100 },
            DEBUG: true
        };
        
        // Enhanced logger for testing
        const testLogger = {
            logs: [],
            info: (msg, data) => testLogger.log('INFO', msg, data),
            warn: (msg, data) => testLogger.log('WARN', msg, data),
            error: (msg, data) => testLogger.log('ERROR', msg, data),
            debug: (msg, data) => testLogger.log('DEBUG', msg, data),
            
            log: (level, msg, data) => {
                const timestamp = new Date().toISOString();
                const logEntry = { timestamp, level, msg, data };
                testLogger.logs.push(logEntry);
                
                if (document.getElementById('enableDebugLogging').checked) {
                    testLogger.displayLog(logEntry);
                }
            },
            
            displayLog: (entry) => {
                const container = document.getElementById('logContainer');
                const div = document.createElement('div');
                div.className = `log-${entry.level.toLowerCase()}`;
                div.textContent = `[${entry.timestamp}] ${entry.level}: ${entry.msg}`;
                if (entry.data) {
                    div.textContent += ` | ${JSON.stringify(entry.data)}`;
                }
                container.appendChild(div);
                container.scrollTop = container.scrollHeight;
            }
        };
        
        // Mock EventBus
        window.EventBus = {
            emit: (event, data) => {
                testLogger.debug(`Event emitted: ${event}`, data);
            }
        };
        
        // Mock Repository for testing
        class MockRepository {
            constructor() {
                this.users = new Map();
                this.nextId = 1;
            }
            
            async execute(functionName, params) {
                testLogger.debug(`Executing RPC function: ${functionName}`, params);
                
                if (document.getElementById('simulateDbFailure').checked) {
                    throw new Error('Simulated database connection failure');
                }
                
                if (document.getElementById('simulateRlsError').checked) {
                    const error = new Error('RLS policy violation');
                    error.code = 'RLS_ERROR';
                    throw error;
                }
                
                if (functionName === 'create_user') {
                    return this.mockCreateUser(params);
                }
                
                throw new Error(`Unknown function: ${functionName}`);
            }
            
            mockCreateUser(params) {
                const existingUser = Array.from(this.users.values())
                    .find(u => u.telegram_id === params.p_telegram_id);
                
                if (existingUser) {
                    return {
                        success: true,
                        user: existingUser,
                        message: 'User already exists',
                        created: false
                    };
                }
                
                const newUser = {
                    id: `user_${this.nextId++}`,
                    telegram_id: params.p_telegram_id,
                    username: params.p_username,
                    first_name: params.p_first_name,
                    last_name: params.p_last_name,
                    points: 100,
                    total_gifts: 0,
                    created_at: new Date().toISOString(),
                    last_login: new Date().toISOString()
                };
                
                this.users.set(newUser.id, newUser);
                
                return {
                    success: true,
                    user: newUser,
                    message: 'User created successfully',
                    created: true
                };
            }
            
            async create(table, data) {
                testLogger.debug(`Direct insert to ${table}`, data);
                
                if (table === 'users') {
                    const newUser = {
                        id: `direct_${this.nextId++}`,
                        ...data
                    };
                    this.users.set(newUser.id, newUser);
                    return newUser;
                }
                
                throw new Error(`Unknown table: ${table}`);
            }
            
            async query(table, conditions, options) {
                testLogger.debug(`Querying ${table}`, { conditions, options });
                
                if (table === 'users' && conditions.telegram_id) {
                    const user = Array.from(this.users.values())
                        .find(u => u.telegram_id === conditions.telegram_id);
                    return options?.single ? user : [user].filter(Boolean);
                }
                
                return options?.single ? null : [];
            }
        }
        
        // Mock platform adapter
        const mockPlatform = {
            getUserData: () => ({
                id: Math.floor(Math.random() * 1000000),
                firstName: 'Test',
                lastName: 'User',
                username: 'testuser'
            })
        };
        
        // Mock DIContainer
        window.DIContainer = {
            get: (service) => {
                if (service === 'giftService') {
                    return {
                        getAvailableGifts: async () => {
                            if (document.getElementById('simulateRlsError').checked) {
                                throw new Error('RLS permission denied for gifts');
                            }
                            return [{ id: 'gift1', name: 'Test Gift' }];
                        }
                    };
                }
                return null;
            }
        };
        
        // Initialize mock auth service
        let authService;
        
        function initializeAuthService() {
            // Import the AuthService (in real scenario this would be loaded)
            authService = {
                repository: new MockRepository(),
                platform: mockPlatform,
                logger: testLogger,
                currentUser: null,
                isAuthenticated: false,
                authToken: null
            };
            
            // Add the enhanced methods (simplified versions for testing)
            authService.authenticate = async function(userData) {
                try {
                    userData = userData || this.platform.getUserData();
                    
                    if (!userData || !userData.id) {
                        throw new Error('No user data available for authentication');
                    }
                    
                    this.logger.info('Authenticating user', { userId: userData.id });
                    
                    let user = await this.getOrCreateUser(userData);
                    
                    if (!user) {
                        throw new Error('Failed to authenticate user');
                    }
                    
                    // Enhanced validation
                    if (!user.id || user.is_local) {
                        this.logger.warn('User creation may have failed, attempting retry', { 
                            userId: user.telegram_id,
                            hasId: !!user.id,
                            isLocal: !!user.is_local 
                        });
                        user = await this.retryUserCreation(userData);
                    }
                    
                    // Verify gift permissions
                    const hasGiftPermissions = await this.validateUserGiftPermissions(user);
                    this.logger.debug('User gift permissions validation result', { 
                        userId: user.telegram_id,
                        hasPermissions: hasGiftPermissions,
                        isLocal: !!user.is_local 
                    });
                    
                    this.currentUser = user;
                    this.isAuthenticated = true;
                    
                    window.EventBus?.emit('auth:success', { user });
                    
                    this.logger.info('User authenticated successfully', { 
                        userId: user.telegram_id,
                        username: user.username,
                        hasDbAccess: !user.is_local
                    });
                    
                    return user;
                    
                } catch (error) {
                    this.logger.error('Authentication failed', error);
                    window.EventBus?.emit('auth:failed', { error: error.message });
                    throw error;
                }
            };
            
            authService.getOrCreateUser = async function(userData) {
                try {
                    const existingUser = await this.getUserByTelegramId(userData.id);
                    
                    if (existingUser) {
                        this.logger.debug('Found existing user', { userId: existingUser.telegram_id });
                        return existingUser;
                    }
                    
                    this.logger.info('Creating new user', { telegramId: userData.id });
                    return await this.createUser(userData);
                    
                } catch (error) {
                    this.logger.error('Failed to get or create user', error);
                    if (error.message.includes('permission') || error.message.includes('RLS')) {
                        return await this.createLocalUser(userData);
                    }
                    throw error;
                }
            };
            
            authService.createUser = async function(userData) {
                try {
                    const newUser = {
                        telegram_id: userData.id,
                        username: userData.username || `User${userData.id}`,
                        first_name: userData.firstName || userData.first_name || null,
                        last_name: userData.lastName || userData.last_name || null,
                        points: 100,
                        total_gifts: 0,
                        created_at: new Date().toISOString(),
                        last_login: new Date().toISOString()
                    };
                    
                    this.logger.debug('Creating user with data', newUser);
                    
                    // Try RPC function first
                    try {
                        this.logger.debug('Attempting to create user via RPC function', { 
                            telegram_id: newUser.telegram_id,
                            username: newUser.username 
                        });
                        
                        const result = await this.repository.execute('create_user', {
                            p_telegram_id: newUser.telegram_id,
                            p_username: newUser.username,
                            p_first_name: newUser.first_name,
                            p_last_name: newUser.last_name
                        });
                        
                        this.logger.debug('RPC create_user result', { result });
                        
                        if (result && result.success) {
                            const createdUser = result.user || newUser;
                            
                            this.logger.info('User created successfully via RPC function', { 
                                userId: createdUser.telegram_id,
                                created: result.created,
                                message: result.message 
                            });
                            
                            window.EventBus?.emit('user:registered', { 
                                user: createdUser,
                                method: 'rpc',
                                created: result.created 
                            });
                            
                            return createdUser;
                        }
                    } catch (rpcError) {
                        this.logger.debug('RPC function failed, trying direct insert', { 
                            error: rpcError.message,
                            telegram_id: newUser.telegram_id 
                        });
                    }
                    
                    // Fallback to direct insert
                    this.logger.debug('Attempting direct user insert', { 
                        telegram_id: newUser.telegram_id 
                    });
                    
                    const createdUser = await this.repository.create('users', newUser);
                    
                    if (!createdUser) {
                        throw new Error('Failed to create user in database');
                    }
                    
                    window.EventBus?.emit('user:registered', { 
                        user: createdUser,
                        method: 'direct_insert'
                    });
                    
                    return createdUser;
                    
                } catch (error) {
                    this.logger.error('Failed to create user in database', error);
                    
                    if (error.message.includes('permission') || error.message.includes('RLS') || error.code === 'RLS_ERROR') {
                        this.logger.warn('Database permission issue, falling back to local storage');
                        return await this.createLocalUser(userData);
                    }
                    
                    throw error;
                }
            };
            
            authService.createLocalUser = async function(userData) {
                const localUser = {
                    id: `local_${userData.id}`,
                    telegram_id: userData.id,
                    username: userData.username || `User${userData.id}`,
                    first_name: userData.firstName || userData.first_name || null,
                    last_name: userData.lastName || userData.last_name || null,
                    points: 100,
                    total_gifts: 0,
                    created_at: new Date().toISOString(),
                    last_login: new Date().toISOString(),
                    is_local: true
                };
                
                this.logger.warn('Created local user due to database issues', { userId: localUser.telegram_id });
                return localUser;
            };
            
            authService.getUserByTelegramId = async function(telegramId) {
                try {
                    const users = await this.repository.query('users', {
                        telegram_id: telegramId
                    }, { single: true });
                    
                    return users;
                } catch (error) {
                    if (error.code === 'PGRST116') {
                        return null;
                    }
                    throw error;
                }
            };
            
            authService.retryUserCreation = async function(userData, maxRetries = 3) {
                let lastError = null;
                
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        this.logger.debug(`User creation retry attempt ${attempt}/${maxRetries}`, { 
                            userId: userData.id 
                        });
                        
                        const existingUser = await this.getUserByTelegramId(userData.id);
                        if (existingUser && !existingUser.is_local) {
                            this.logger.info('Found existing database user on retry', { 
                                userId: existingUser.telegram_id,
                                attempt 
                            });
                            return existingUser;
                        }
                        
                        const newUser = await this.createUser(userData);
                        
                        if (newUser && !newUser.is_local) {
                            this.logger.info('User creation successful on retry', { 
                                userId: newUser.telegram_id,
                                attempt 
                            });
                            return newUser;
                        }
                        
                        if (newUser && newUser.is_local && attempt < maxRetries) {
                            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                            continue;
                        }
                        
                        return newUser;
                        
                    } catch (error) {
                        lastError = error;
                        this.logger.warn(`User creation retry ${attempt} failed`, { 
                            error: error.message,
                            userId: userData.id 
                        });
                        
                        if (attempt < maxRetries) {
                            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                        } else {
                            this.logger.error('All user creation retries failed, using local fallback', { 
                                error: error.message,
                                userId: userData.id 
                            });
                            return await this.createLocalUser(userData);
                        }
                    }
                }
                
                throw lastError || new Error('Failed to create user after retries');
            };
            
            authService.validateUserGiftPermissions = async function(user) {
                try {
                    if (user.is_local) {
                        this.logger.warn('User is in local mode - gift purchases may not work', { 
                            userId: user.telegram_id 
                        });
                        return false;
                    }
                    
                    const giftService = window.DIContainer?.get('giftService');
                    if (giftService) {
                        try {
                            await giftService.getAvailableGifts();
                            this.logger.debug('User gift permissions validated successfully', { 
                                userId: user.telegram_id 
                            });
                            return true;
                        } catch (giftError) {
                            this.logger.warn('User may not have proper gift access permissions', { 
                                userId: user.telegram_id,
                                error: giftError.message 
                            });
                            return false;
                        }
                    }
                    
                    return true;
                    
                } catch (error) {
                    this.logger.error('Failed to validate user gift permissions', error, { 
                        userId: user.telegram_id 
                    });
                    return false;
                }
            };
        }
        
        // Test functions
        async function testNewUserCreation() {
            addTestResult('üß™ Testing New User Creation...');
            
            try {
                initializeAuthService();
                const userData = mockPlatform.getUserData();
                
                const user = await authService.authenticate(userData);
                
                addTestResult(`‚úÖ New user created successfully:
- ID: ${user.telegram_id}
- Username: ${user.username}
- Is Local: ${user.is_local || false}
- Has DB Access: ${!user.is_local}`);
                
            } catch (error) {
                addTestResult(`‚ùå New user creation failed: ${error.message}`, true);
            }
        }
        
        async function testExistingUserAuth() {
            addTestResult('üß™ Testing Existing User Authentication...');
            
            try {
                if (!authService || !authService.currentUser) {
                    await testNewUserCreation();
                }
                
                const existingUserData = {
                    id: authService.currentUser.telegram_id,
                    username: authService.currentUser.username,
                    firstName: authService.currentUser.first_name
                };
                
                const user = await authService.authenticate(existingUserData);
                
                addTestResult(`‚úÖ Existing user authenticated successfully:
- ID: ${user.telegram_id}
- Found existing record: ${!user.is_local}`);
                
            } catch (error) {
                addTestResult(`‚ùå Existing user authentication failed: ${error.message}`, true);
            }
        }
        
        async function testRetryMechanism() {
            addTestResult('üß™ Testing Retry Mechanism...');
            
            try {
                initializeAuthService();
                
                // Simulate initial failure
                document.getElementById('simulateDbFailure').checked = true;
                
                const userData = mockPlatform.getUserData();
                
                const user = await authService.authenticate(userData);
                
                addTestResult(`‚úÖ Retry mechanism worked:
- User created: ${user.telegram_id}
- Method used: ${user.is_local ? 'Local fallback' : 'Database'}`);
                
                // Reset simulation
                document.getElementById('simulateDbFailure').checked = false;
                
            } catch (error) {
                addTestResult(`‚ùå Retry mechanism failed: ${error.message}`, true);
                document.getElementById('simulateDbFailure').checked = false;
            }
        }
        
        async function testGiftPermissions() {
            addTestResult('üß™ Testing Gift Permissions Validation...');
            
            try {
                if (!authService || !authService.currentUser) {
                    await testNewUserCreation();
                }
                
                const hasPermissions = await authService.validateUserGiftPermissions(authService.currentUser);
                
                addTestResult(`‚úÖ Gift permissions validation completed:
- User: ${authService.currentUser.telegram_id}
- Has permissions: ${hasPermissions}
- Is local user: ${authService.currentUser.is_local || false}`);
                
            } catch (error) {
                addTestResult(`‚ùå Gift permissions test failed: ${error.message}`, true);
            }
        }
        
        function addTestResult(message, isError = false) {
            const container = document.getElementById('testResults');
            const div = document.createElement('div');
            div.className = isError ? 'test-result test-error' : 'test-result';
            div.textContent = message;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }
        
        function clearLogs() {
            document.getElementById('logContainer').innerHTML = '';
            document.getElementById('testResults').innerHTML = '';
            testLogger.logs = [];
        }
        
        // Initialize on page load
        window.addEventListener('load', () => {
            addTestResult('üöÄ Authentication Enhancement Test Ready');
            addTestResult('Run tests to validate the enhanced authentication flow');
        });
    </script>
</body>
</html>